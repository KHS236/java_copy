package CH05;

//	부모
class Super{
	int n1;
}


//	자식
class Sub extends Super{
	int n2;
}




public class C06UpDownCastingMain {

	public static void main(String[] args) {

		// 캐스팅 == 형변환
		//Nocasting(형변환 없음 / 자료형 일치)
		Super ob1 = new Super();
		ob1.n1 = 10;
		Sub ob2 = new Sub();
		ob2.n1 = 10;
		ob2.n2 = 20;
				
//		==============================================================================
		//Upcasting(상위클래스 최종변수 / 하위클래스랑 객체) (자동형변환)
		
		Super ob3 = new Sub();
		//Super는 만들어질 때 n1밖에 모름
		// 사실상 얘는 쓸 수 있는 범위를 가리키는 애
		ob3.n1 = 100;
//		ob3.n?
		Super ob4 = ob2;
		ob4.n1 = 200;
//		ob2를 넣어도 n2는 Super는 n1밖에 모름 
//		ob4.n?
		
//		ob2는 Sub자료형이었는데 자동형변환이 일어났다
//		그럼 왜 ? 자동형변환이 일어나는 이유
//		당연하게도 하위 클래스는 상위클래스보다 멤버변수가 늘면늘지 줄진 않아서 메모리 공간이 더 넓다
//		상위클래스가 메모리 영역을 침범할 우려가 없기 때문에 자동으로 형변환해도 문제가 없다고 판단
//		Upcasting을 사용하는 이유
//		1) 상속관계에 있는 모든 하위클래스로 객체가 만들어졌을 때 그 객체들 모두 일단 연결할 수 있다
//		2) Upcasting된 상태에서는 재정의된 함수에 접근이 가능하다.
		
		
		
		//===========================================================================
		// DownCasting(하위클래스 참조변수 = 상위클래스형 객체) (강제형변환)
//		다운캐스팅 ?
//		업캐스팅을 전제로해서 접근할 수 없었떤 확장된 부분 ex)n2에 접근이 안 됐던 부분에 접근하기 위해 사용
		
//		업캐스팅 전제가 없다면?
//		Sub ob5 = (Sub)ob1; //상위클래스 객체 ob1이랑 연결
//		ob5.n1=100; //실제 있는 n1공간에 값 대입(문제 없음)
//		ob5.n2=200; //컴파일 수준에서 문제가 없어보이지만 실행하면 예외발생
		// 문제없어 보이지만 Sub ob5 = (Sub)ob1;에서 이미 예외를 잡아냄
		
		Sub down = (Sub)ob4; //Upcasting을 전제로 한 Downcasting
		down.n1 = 1000;
		down.n2 = 1000; //n2 접근 가능
		
		
		
		
		

	}

}
